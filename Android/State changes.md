### 활동 상태 변경
Activity가 한 상태에서 다른 상태로 변경 되는 것

### 구성 변경 발생
액티비티에서 구성이 변할 수 있는 여러 이벤트가 존재한다. 아마 가장 많이 일어나는 예는 세로모드와 가로모드의 방향 변화일 것이다. 
+ 만약 구성변경이 발생하면 액티비티는 제거되고 완전히 새로 생성됩니다. 즉, onPause(), onStop() 및 onDestory() 콜백 메서드가 호출이 되는데 이러한 상황이 일어나면 유지되고 있던 UI 상태를 완전히 잃게 됩니다. 
UI 상태를 유지하기 위해서는 ViewModel, onSaveInstanceState() 메서드 또는 영구 로컬 저장소의 조합을 활용해야만 합니다. 
+ 구성 변경이 발생하면 onPasue() -> on Stop() -> onDestory()그리고 활동이 새 인스턴스가 생성 되면 on Create() -> on Start() -> on Resume()순으로 콜백이 된다.

### 멀티 윈도우
앱이 멀티 윈도우 모드로 전환되면 시스템은 현재 실행 중인 액티비티에게 구성 변경을 알립니다. 이에 따라 위에서 언급한 액티비티 수명 주기 전환을 거치게 됩니다.

멀티 윈도우 모드에서는 사용자에게 표시되는 앱이 두개 있더라도 사용자가 상호작용하고 있는 앱만 포그라운드에 있으며 포커스를 가지게 됩니다. 이 액티비티는 '다시 시작됨' 상태를 갖게 되지만, 다른 창의 앱은 '일시중지됨' 상태를 가지게 됩니다.

만약 사용자가 앱 A에서 앱 B로 전환할 때 시스템은 앱 A에 onPause()를 호출하고 앱 B에 onResume()를 호출합니다. 사용자가 앱을 전환할 때마다 위의 과정이 반복됩니다.

### 포커스의 변경
새 액티비티가 포그라운드로 나옴에 따라 포커스를 얻게되고 진행중이였던 액티비티를 부분적으로 가리게 되면 가려진 액티비티는 포커스를 잃고 '일시중지됨' 상태로 전환됩니다. 그러면 시스템은 그 액티비티에 onPause()를 호출하게 됩니다.  

만약에 가려졌던 액티비티가 포그라운드에 돌아와서 포커스를 다시 얻게되면 시스템은 onResume()를 호출하게됩니다. 새 액티비티가 포그라운드에 나옴에 따라 진행중이던 액티비티를 부분적이 아닌 완전하게 가리게 되면 가려진 액티비티는 '중지됨' 상태로 전환됩니다. 그러면 시스템은 onPause()와 onStop()을 빠르게 연속적으로 호출합니다.

'중지됨' 상태로 있던 액티비티의 동일한 인스턴스가 포그라운드로 다시 돌아오면 시스템은 액티비티에 onRestart(), onStart(), onResume()를 호출합니다. 만약, 동일한 인스턴스가 아닌 새로 만들어진 인스턴스라면 onStart()와 onResume()만 호출하게 됩니다.

### 사용자가 뒤로가기 버튼을 탭한 경우
액티비티가 포그라운드에 나와있는 상태에서 사용자가 뒤로 가기 버튼을 탭하면 액티비티는 onPause(), onStop() 및 onDestory() 콜백 메서드를 거치며 전환됩니다. 또한 액티비티는 제거될 뿐만 아니라 백 스택에서도 삭제됩니다.

이러한 상황에서는 기본적으로 onSaveInstaceState() 콜백메서드가 호출되지 않는다는 점을 인지하고 있어야만 합니다. 이 상황은 사용자가 액티비티의 동일한 인스턴스로 돌아오지 않을 것이라 가정합니다.

물론, onBackPressed() 메서드를 재정의하면 액티비티가 사라지기 전에 실행되는 특정한 동작을 구현할 수 있습니다. onBackPressed() 메서드를 오버라이드 할 때는 super.onBackPressed()를 호출해야만 합니다. 만약 호출하지 않는다면 사용자에게 굉장히 부자연스러운 동작으로 보일수도 있습니다.

### 앱 강제종료
앱이 백그라운드에 있는데 시스템이 포그라운드에 위치한 앱을 위해 추가적인 메모리를 확보해야 하면 시스템은 백그라운드 앱을 강제 종료 시킬수도 있습니다. 시스템이 특정 앱을 종료할 가능성은 그 시점의 앱의 상태에 따라 달라집니다. 앱의 정지됨 - 일시정지됨 - 생성,시작,재개됨 순으로 시스템으로부터 종료될 가능성이 낮아집니다.