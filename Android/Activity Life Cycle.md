### Activity Life Cycle
 Android 앱 개발에서 매우 중요한 개념으로, 안드로이드 앱의 각 액티비티가 생성, 실행, 중단, 재개, 종료되는 과정에서 시스템이 호출하는 일련의 메서드를 의미

 ### Activity Life Cycle 동작 원리
 핵심 콜백 메소드로는 onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy() 이렇게 6가지가 존재

 ### onCreate()
시스템이 액티비티를 생성할 때 실행되는 녀석이다. 다른 콜백 메소드들과 다르게, 이 콜백메소드는 꼭 오버라이딩하여 구현해야 한다. 이 메소드에는 액티비티 전체 수명 주기 동안 딱 한 번만 동작되는 초기화 및 시작 로직을 실행
+ onCreate() 는 **savedInstanceState 라는 파라미터를 수신하는데, 이는 액티비티의 이전 상태가 저장**된 Bundle 객체에 해당된다. (처음 생성된 액티비티인 경우 null 을 담고 있음) 이를 통해 이전 상태를 복원하여 화면에 표시할 수 있다.
+ onCreate() 의 동작이 끝났다고 해서 액티비티가 종료되는 것이 아니고, 액티비티가 'STARTED' 상태에 진입하게 되어 시스템은 onStart() 와 onResume() 을 연달아 호출하게 된다.

### onStart()
액티비티가 onCreate() 를 호출한 뒤 액티비티가 'STARTED' 상태에 진입하게 되면 onStart() 가 호출된다. 이 메소드가 호출되면 액티비티가 사용자에게 보여지고, 포그라운드 태스크로써 사용자와 상호작용할 수 있도록 준비한다. 그리고 onStart() 는 매우 빠른 속도로 실행되고, 액티비티가 'RESUMED' 상태에 진입함과 동시에 onResume() 메소드를 호출하게 된다.

### onResume()
액티비티가 'RESUMED' 상태에 진입하게 되면 포그라운드에 액티비티가 표시되고 앱이 사용자와 상호작용을 할 수 있는 상태가 된다. 어떤 방해 이벤트 및 인터럽트 (전화가 오거나 화면을 슬립하는 등 이벤트) 가 발생하여 사용자의 포커스가 없어지지 않는 이상, 이제 앱은 'RESUMED' 상태에 머무르게 된다.
+ 포그라운드에서 사용자에게 액티비티가 보여지는 동안 실행해야 하는 모든 기능을 활성화 할 수 있게 된다.
+ 방해 이벤트가 발생하면, 액티비티는 'PAUSED' 상태에 들어가게 되어 시스템이 onPause() 콜백 메소드를 호출하게 된다.

### onPause()
사용자가 잠시 액티비티를 떠났을 때 (다른 액티비티에 포커스를 뒀을 때) 호출되는 콜백 메소드이다. 즉, 해당 액티비티가 포그라운드에 있지 않게 되었다는 것을 의미 한다. 
+ 액티비티가 'PAUSED' 상태에 진입하게 되는 여러가지 루트들
앱이 실행되던 중 방해 이벤트 및 인터럽트가 발생한 경우 (전화가 갑자기 오는 경우)
+ 위에서 말한 것 처럼, 멀티 윈도우 상 다른 앱에 포커스를 두는 경우
+ 화면에 반투명한 액티비티가 열리는 경우 e.g. 권한 요청 다이얼로그

+ ⛔️꼭 집고 넘어가야 하는 사실!! onPause() 는 아주 잠깐 실행되기 때문에 무언갈 저장하는 작업을 실행하기엔 시간이 부족할 수 있다. 따라서 onPause() 내에서는 사용자 데이터 저장, 네트워크 호출, DB 트랜잭션 등을 실행해서는 안 된다. 이렇게 부하가 큰 작업들은 onStop() 에서 수행해야 한다.

### onStop()
액티비티가 사용자에게 더 이상 표시되지 않으면 'STOPPED' 상태에 진입하고 시스템이 onStop() 콜백 메소드를 호출한다. 즉, 새로 시작된 액티비티가 화면 전체를 차지할 경우에 해당된다. 혹은 액티비티의 실행이 완료되어 종료될 시점에 onStop() 를 호출할 수도 있다.
+  UI 관련 중지 작업을 할 때는 onPause(), onStop() 중 어떤 것을 사용해야 할까?
+ onStop() 을 사용해야 멀티 윈도우를 사용하여 동시에 두 앱을 구동시키고 있어도 애니메이션 등 UI 구성 요소가 멈추지 않는다. 왜냐하면, 멀티 윈도우의 다른 앱으로 포커스를 조정하는 순간 onPause() 가 호출되기 때문이다. onPause() 내에 UI 중지 작업을 수행해버리면, 멀티 윈도우 상으로 액티비티는 화면에 표시되고 있는데도 UI 가 멈추어버리는 현상이 발생하게 된다. 이러한 이유로, UI 관련 마무리 작업은 onStop() 에서 수행하는 것이 낫다.

+ 💡 Tip 💡
액티비티가 'STOPPED' 상태에 들어가더라도 액티비티 객체는 메모리 안에 머무른다. 그런데 시스템이 더 우선순위가 높은 프로세스를 위해 메모리를 확보해야하는 경우, 이 액티비티를 메모리 상에서 죽이게 된다. 하지만 그럼에도 Bundle 에 View 객체 상태를 그대로 저장해두고, 사용자가 이 액티비티로 다시 돌아오게 되면 이를 기반으로 상태를 복원한다. (꽤나 잘 돌아간다)
+ 만약 사용자가 다시 액티비티로 돌아오게 되면, 'STOPPED' 상태에서 다시 시작되어 onRestart() → onStart() → onResume() 이 연달아 호출되며 'RESUMED' 상태로 변화하여 다시 포그라운드 액티비티로써의 태스크를 시작하며 사용자와 상호작용을 시작한다. 

### onDestory()
액티비티가 완전히 소멸되기 전에 이 콜백 메소드가 호출된다. 아래와 같은 경우 액티비티가 완전히 소멸된다.
+ finish() 가 호출되거나 사용자가 앱을 종료하여 액티비티가 종료되는 경우
+ 화면 구성이 변경되어 (기기 회전 등) 일시적으로 액티비티를 소멸시키는 경우

+ ⛔️ 꼭 짚고 넘어가야 할 사실!
만약 onDestroy() 가 호출되기 까지 해제되지 않은 리소스가 있다면, 모두 여기서 해제해줘야 한다. Memory Leak (메모리 누수) 의 위험이 있다.